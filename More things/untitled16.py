# -*- coding: utf-8 -*-
"""Untitled16.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_ySGVqRK84cqTwXvP5XSrkEFHKhjrDgz
"""

import re
from typing import List
from google.colab import files

def load_file(filename: str) -> str:
    print(f"Please upload the file '{filename}'")
    uploaded = files.upload()
    if filename not in uploaded:
        raise ValueError(f"File '{filename}' was not uploaded. Please run the cell again and upload the correct file.")
    return uploaded[filename].decode('utf-8')

def load_entity_names(content: str) -> List[str]:
    return [line.strip() for line in content.split('\n') if line.strip()]

def load_ocr_text(content: str) -> List[str]:
    return [line.strip() for line in content.split('\n') if line.strip()]

def convert_to_standard_unit(value: float, unit: str) -> tuple:
    if unit in ['gram', 'g']:
        return value, 'gram'
    elif unit in ['kilogram', 'kg']:
        return value * 1000, 'gram'
    elif unit in ['milligram', 'mg']:
        return value / 1000, 'gram'
    elif unit in ['ounce', 'oz']:
        return value * 28.34952, 'gram'
    elif unit in ['pound', 'lb']:
        return value * 453.592, 'gram'
    elif unit in ['cup']:
        return value, 'cup'
    elif unit in ['gallon', 'gal']:
        return value * 3.78541, 'liter'
    elif unit in ['milliliter', 'ml']:
        return value / 1000, 'liter'
    elif unit in ['volt', 'v']:
        return value, 'volt'
    elif unit in ['watt', 'w']:
        return value, 'watt'
    elif unit in ['cubic foot', 'cu ft']:
        return value * 28.3168, 'liter'
    else:
        return value, unit

def extract_value_unit(text: str) -> str:
    match = re.match(r'(\d+(?:\.\d+)?)\s*([\w\s]+)', text)
    if match:
        value = float(match.group(1))
        unit = match.group(2).strip().lower()
        value, unit = convert_to_standard_unit(value, unit)
        return f"{value:.2f} {unit}"
    return ""

def process_data(entity_names: List[str], ocr_text: List[str]) -> List[str]:
    results = []
    for text in ocr_text:
        results.append(extract_value_unit(text))
    return results

def main():
    try:
        # Load entity names (not used in this version, but kept for compatibility)
        entity_names_content = load_file('entity_value_100.txt')
        entity_names = load_entity_names(entity_names_content)
        print("Entity names loaded successfully.")

        # Load OCR text
        ocr_text_content = load_file('new1.txt')
        ocr_text = load_ocr_text(ocr_text_content)
        print("OCR text loaded successfully.")

        # Process data
        results = process_data(entity_names, ocr_text)

        # Create output
        output = "index,prediction\n"
        for i, prediction in enumerate(results):
            output += f"{i},{prediction}\n"

        # Save output to file
        with open('predictions.csv', 'w') as f:
            f.write(output)

        # Download the file
        files.download('predictions.csv')

        print("Processing complete. The predictions.csv file has been downloaded.")
    except Exception as e:
        print(f"An error occurred: {str(e)}")
        print("Please make sure you've uploaded the correct files and try again.")

print("Instructions:")
print("1. Run this cell.")
print("2. Upload 'entity_value_100.txt' when prompted.")
print("3. After uploading 'entity_value_100.txt', you will be prompted to upload 'new1.txt'.")
print("4. The script will process the data and download 'predictions.csv' with the results.")
print("5. If you encounter any errors, please read the error message and try again.")

main()



!pip install spacy
!python -m spacy download en_core_web_sm

from google.colab import files

uploaded = files.upload()

for fn in uploaded.keys():
  print('User uploaded file "{name}" with length {length} bytes'.format(
      name=fn, length=len(uploaded[fn])))

import spacy
from spacy.pipeline import EntityRuler
import re
a=0
# Load spaCy model
nlp = spacy.load("en_core_web_sm")

# Create custom entity ruler
ruler = EntityRuler(nlp)

# Define patterns for weight and volume
patterns = [
    {"label": "WEIGHT", "pattern": [{"LOWER": {"REGEX": "^[0-9,.]+$"}}, {"LOWER": {"IN": ["mg", "g", "kg", "oz", "lbs", "gram", "grams", "kilogram", "kilograms", "ounce", "ounces", "pound", "pounds"]}}]},
    {"label": "VOLUME", "pattern": [{"LOWER": {"REGEX": "^[0-9,.]+$"}}, {"LOWER": {"IN": ["ml", "l", "oz", "fl oz", "milliliter", "milliliters", "liter", "liters", "ounce", "ounces", "fluid ounce", "fluid ounces"]}}]},
    {"label": "WATTAGE", "pattern": [{"LOWER": {"REGEX": "^[0-9,.]+$"}}, {"LOWER": "w"}]},
    {"label": "VOLTAGE", "pattern": [{"LOWER": {"REGEX": "^[0-9,.]+$"}}, {"LOWER": "v"}]}
]

# Add patterns to the ruler
ruler.add_patterns(patterns)

# Add the ruler to the pipeline
nlp.add_pipe("entity_ruler", config={"overwrite_ents": True})
nlp.get_pipe("entity_ruler").add_patterns(patterns)

def extract_entity(text, entity_type):
    doc = nlp(text)
    for ent in doc.ents:
        if ent.label_ == entity_type:
            value = re.findall(r'[\d.]+', ent.text)[0]
            unit = re.findall(r'[a-zA-Z]+', ent.text)[0]
            return f"{float(value)} {unit}"
    return None

# Read the text snippets and entity types
with open('extracted_text.txt', 'r') as f:
    text_snippets = [line.strip() for line in f.readlines() if line.strip()]

with open('entity_name.txt', 'r') as f:
    entity_types = [line.strip() for line in f.readlines() if line.strip()]

# Process each text snippet and extract the relevant entity
for text, entity_type in zip(text_snippets, entity_types):
    if entity_type == "item_weight":
        result = extract_entity(text, "WEIGHT")
    elif entity_type == "item_volume":
        result = extract_entity(text, "VOLUME")
    elif entity_type == "wattage":
        result = extract_entity(text, "WATTAGE")
    elif entity_type == "voltage":
        result = extract_entity(text, "VOLTAGE")
    else:
        result = None
    if result==None:
      print(f"Text: {text}")
      print(f"Entity Type: {entity_type}")
      print(f"Extracted Value: {result}")
    if result == None:
      a=a+1
    #print()

print(a)

import spacy
from spacy.pipeline import EntityRuler
import re
import os
import csv

# Load spaCy model
nlp = spacy.load("en_core_web_sm")

# Define expanded patterns for weight (including milligrams), volume, wattage, and voltage
patterns = [
    {"label": "WEIGHT", "pattern": [{"LOWER": {"REGEX": "^[0-9,.-]+$"}}, {"LOWER": {"REGEX": "^(mg|g|kg|kgs?|oz|lbs?|milligram|gram|grams|kilogram|kilograms|ounce|ounces|pound|pounds)s?$"}}]},
    {"label": "WEIGHT", "pattern": [{"LOWER": {"REGEX": "^[0-9,.-]+$"}}, {"LOWER": "kg"}]},  # Specific pattern for 'KG'
    {"label": "VOLUME", "pattern": [{"LOWER": {"REGEX": "^[0-9,.-]+$"}}, {"LOWER": {"REGEX": "^(ml|l|oz|fl\s?oz|milliliter|milliliters|liter|liters|ounce|ounces|fluid\s?ounce|fluid\s?ounces)s?$"}}]},
    {"label": "WATTAGE", "pattern": [{"LOWER": {"REGEX": "^[0-9,.-]+$"}}, {"LOWER": {"IN": ["w", "watt", "watts"]}}]},
    {"label": "VOLTAGE", "pattern": [{"LOWER": {"REGEX": "^[0-9,.-]+$"}}, {"LOWER": {"IN": ["v", "volt", "volts"]}}]}
]

# Create and add the EntityRuler to the pipeline
ruler = nlp.add_pipe("entity_ruler", before="ner", config={"overwrite_ents": True})
ruler.add_patterns(patterns)

def fuzzy_unit_match(text, unit_type):
    units = {
        "WEIGHT": ["mg", "g", "kg", "kgs", "oz", "lbs", "milligram", "milligrams", "gram", "grams", "kilogram", "kilograms", "ounce", "ounces", "pound", "pounds", "KG"],
        "VOLUME": ["ml", "l", "oz", "fl oz", "milliliter", "milliliters", "liter", "liters", "ounce", "ounces", "fluid ounce", "fluid ounces"],
        "WATTAGE": ["w", "watt", "watts"],
        "VOLTAGE": ["v", "volt", "volts"]
    }

    for unit in units[unit_type]:
        if unit.lower() in text.lower():
            return unit
    return None

def extract_entity(text, entity_type):
    # If text is a list, join it into a single string
    if isinstance(text, list):
        text = ' '.join(text)

    # Special case for weight
    if entity_type == "WEIGHT":
        weight_pattern = r'(\d+(?:\.\d+)?)\s*(?:kg|KG|g|G|lbs?|LBS?|ounces?|oz)'
        weight_matches = re.findall(weight_pattern, text, re.IGNORECASE)

        if weight_matches:
            # Return the last match, which is likely to be the "Battery Weight"
            value = weight_matches[-1]
            unit = re.search(r'(kg|KG|g|G|lbs?|LBS?|ounces?|oz)', text[text.index(value):], re.IGNORECASE).group(1)
            return f"{float(value)} {unit.lower()}"

    # Special case for voltage
    if entity_type == "VOLTAGE":
        voltage_pattern = r'(\d+(?:\.\d+)?)\s*[Vv](?!\w)'
        voltage_match = re.search(voltage_pattern, text)
        if voltage_match:
            return f"{float(voltage_match.group(1))} V"

    # First, try to find a value in parentheses
    parentheses_pattern = r'\(([\d.,]+)\s*([a-zA-Z]+)\)'
    parentheses_match = re.search(parentheses_pattern, text)
    if parentheses_match:
        value, unit = parentheses_match.groups()
        if (entity_type == "VOLTAGE" and unit.lower() == 'v') or \
           (entity_type == "WATTAGE" and unit.lower() == 'w') or \
           (entity_type in ["WEIGHT", "VOLUME"]):
            return f"{float(value.replace(',', ''))} {unit.lower()}"

    doc = nlp(text)

    # Try spaCy entity extraction
    for ent in doc.ents:
        if ent.label_ == entity_type:
            value = re.findall(r'[\d.,]+', ent.text)[0]
            unit = re.findall(r'[a-zA-Z]+', ent.text)[0]
            return f"{float(value.replace(',', ''))} {unit.lower()}"

    # If spaCy fails, try regex-based extraction
    value_pattern = r'(\d+(?:[.,]\d+)?)'
    unit = fuzzy_unit_match(text, entity_type)

    if unit:
        matches = re.findall(f"{value_pattern}\s*{re.escape(unit)}", text, re.IGNORECASE)
        if matches:
            return f"{float(matches[0].replace(',', ''))} {unit.lower()}"

    # If all else fails, look for any number followed by a known unit
    units = {
        "WEIGHT": ["kg", "g", "mg", "oz", "lbs"],
        "VOLUME": ["l", "ml", "fl oz"],
        "WATTAGE": ["w"],
        "VOLTAGE": ["v"]
    }
    for unit in units[entity_type]:
        matches = re.findall(f"{value_pattern}\s*{unit}", text, re.IGNORECASE)
        if matches:
            return f"{float(matches[0].replace(',', ''))} {unit.lower()}"

    # If still no match, look for any number in the text
    numbers = re.findall(value_pattern, text)
    if numbers:
        #return f"{float(numbers[0].replace(',', ''))} (unit not found)"
        return None

    return None

def get_file_path(file_name):
    if os.path.exists(file_name):
        return file_name
    else:
        user_path = input(f"'{file_name}' not found. Please enter the full path to the file: ")
        if os.path.exists(user_path):
            return user_path
        else:
            raise FileNotFoundError(f"File '{user_path}' not found.")

def get_input_data():
    try:
        text_file = get_file_path('extracted_text.txt')
        entity_file = get_file_path('entity_name.txt')

        with open(text_file, 'r') as f:
            text_snippets = [line.strip() for line in f.readlines() if line.strip()]
        with open(entity_file, 'r') as f:
            entity_types = [line.strip() for line in f.readlines() if line.strip()]

        return text_snippets, entity_types
    except FileNotFoundError as e:
        print(f"Error: {e}")
        return None, None

def write_to_csv(data, filename='extracted_values.csv'):
    # Write data to a CSV file with an Index column
    with open(filename, 'w', newline='') as csvfile:
        fieldnames = ['Index', 'Extracted Value']
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)

        writer.writeheader()
        for index, row in enumerate(data):
            writer.writerow({
                'Index': index,
                'Extracted Value': row['Extracted Value']
            })

# Get input data
text_snippets, entity_types = get_input_data()

if text_snippets and entity_types:
    # Prepare data for CSV
    extracted_data = []

    for text, entity_type in zip(text_snippets, entity_types):
        if entity_type == "item_weight":
            result = extract_entity(text, "WEIGHT")
        elif entity_type == "item_volume":
            result = extract_entity(text, "VOLUME")
        elif entity_type == "wattage":
            result = extract_entity(text, "WATTAGE")
        elif entity_type == "voltage":
            result = extract_entity(text, "VOLTAGE")
        else:
            result = None

        extracted_data.append({
            'Extracted Value': result
        })

        print(f"Text: {text}")
        print(f"Entity Type: {entity_type}")
        print(f"Extracted Value: {result}")
        print()

    # Write the extracted data to CSV
    write_to_csv(extracted_data)

else:
    print("Unable to process data due to missing input files.")

import spacy
from spacy.pipeline import EntityRuler
import re
import os
import csv

# Load spaCy model
nlp = spacy.load("en_core_web_sm")

# Define expanded patterns for weight (including milligrams), volume, wattage, and voltage
patterns = [
    {"label": "WEIGHT", "pattern": [{"LOWER": {"REGEX": "^[0-9,.-]+$"}}, {"LOWER": {"REGEX": "^(mg|g|kg|kgs?|oz|lbs?|milligram|gram|grams|kilogram|kilograms|ounce|ounces|pound|pounds)s?$"}}]},
    {"label": "WEIGHT", "pattern": [{"LOWER": {"REGEX": "^[0-9,.-]+$"}}, {"LOWER": "kg"}]},  # Specific pattern for 'KG'
    {"label": "VOLUME", "pattern": [{"LOWER": {"REGEX": "^[0-9,.-]+$"}}, {"LOWER": {"REGEX": "^(ml|l|oz|fl\s?oz|milliliter|milliliters|liter|liters|ounce|ounces|fluid\s?ounce|fluid\s?ounces)s?$"}}]},
    {"label": "WATTAGE", "pattern": [{"LOWER": {"REGEX": "^[0-9,.-]+$"}}, {"LOWER": {"IN": ["w", "watt", "watts"]}}]},
    {"label": "VOLTAGE", "pattern": [{"LOWER": {"REGEX": "^[0-9,.-]+$"}}, {"LOWER": {"IN": ["v", "volt", "volts"]}}]},

    {"label": "MAXIMUM_WEIGHT_RECOMMENDATION", "pattern": [{"LOWER": {"REGEX": "^[0-9,.-]+$"}}, {"LOWER": {"IN": ["mg", "g", "kg", "kgs", "oz", "lbs", "milligram", "milligrams", "gram", "grams", "kilogram", "kilograms", "ounce", "ounces", "pound", "pounds", "kg"]}}]},

    {"label": "HEIGHT", "pattern": [{"LOWER": {"REGEX": "^[0-9,.-]+$"}}, {"LOWER": {"IN": ["cm", "ft", "in", "m", "mm", "yard", "yd", "centimetre", "foot", "inch", "metre", "millimetre"]}}]},

    {"label": "WIDTH", "pattern": [{"LOWER": {"REGEX": "^[0-9,.-]+$"}}, {"LOWER": {"IN": ["cm", "ft", "in", "m", "mm", "yard", "yd", "centimetre", "foot", "inch", "metre", "millimetre"]}}]},

    {"label": "DEPTH", "pattern": [{"LOWER": {"REGEX": "^[0-9,.-]+$"}}, {"LOWER": {"IN": ["cm", "ft", "in", "m", "mm", "yard", "yd", "centimetre", "foot", "inch", "metre", "millimetre"]}}]},

    {"label": "item_volume", "pattern": [{"LOWER": {"REGEX": "^[0-9,.-]+$"}}, {"LOWER": {"IN": ["centilitre", "cl", "cubic foot", "ft³", "cubic inch", "in³", "cup", "cup", "decilitre", "dl", "fluid ounce", "fl oz", "gallon", "gal", "imperial gallon", "imp gal", "litre", "l", "microlitre", "µl", "millilitre", "ml", "pint", "pt", "quart", "qt"]}}]}
]


# Create and add the EntityRuler to the pipeline
ruler = nlp.add_pipe("entity_ruler", before="ner", config={"overwrite_ents": True})
ruler.add_patterns(patterns)

def fuzzy_unit_match(text, unit_type):
    units = {
        "WEIGHT": ["mg", "g", "kg", "kgs", "oz", "lbs", "milligram", "milligrams", "gram", "grams", "kilogram", "kilograms", "ounce", "ounces", "pound", "pounds", "KG"],
        "VOLUME": ["ml", "l", "oz", "fl oz", "milliliter", "milliliters", "liter", "liters", "ounce", "ounces", "fluid ounce", "fluid ounces"],
        "WATTAGE": ["w", "watt", "watts"],
        "VOLTAGE": ["v", "volt", "volts"],
        "MAXIMUM_WEIGHT_RECOMMENDATION":["mg", "g", "kg", "kgs", "oz", "lbs", "milligram", "milligrams", "gram", "grams", "kilogram", "kilograms", "ounce", "ounces", "pound", "pounds", "KG"],
        "HEIGHT" :["cm","ft","in","m","mm","yard","yd","centimetre","foot","inch","metre","millimetre"],
        "WIDTH" :["cm","ft","in","m","mm","yard","yd","centimetre","foot","inch","metre","millimetre"],
        "DEPTH" :["cm","ft","in","m","mm","yard","yd","centimetre","foot","inch","metre","millimetre"],
        'item_volume': ['centilitre', 'cl', 'cubic foot', 'ft³', 'cubic inch', 'in³', 'cup', 'cup', 'decilitre', 'dl', 'fluid ounce', 'fl oz', 'gallon', 'gal', 'imperial gallon', 'imp gal', 'litre', 'l', 'microlitre', 'µl', 'millilitre', 'ml', 'pint', 'pt', 'quart', 'qt']


    }

    for unit in units[unit_type]:
        if unit.lower() in text.lower():
            return unit
    return None

def extract_entity(text, entity_type):
    # If text is a list, join it into a single string
    if isinstance(text, list):
        text = ' '.join(text)

    # Special case for weight
    if entity_type == "WEIGHT":
        weight_pattern = r'(\d+(?:\.\d+)?)\s*(?:kg|KG|g|G|lbs?|LBS?|ounces?|oz)'
        weight_matches = re.findall(weight_pattern, text, re.IGNORECASE)

        if weight_matches:
            # Return the last match, which is likely to be the "Battery Weight"
            value = weight_matches[-1]
            unit = re.search(r'(kg|KG|g|G|lbs?|LBS?|ounces?|oz)', text[text.index(value):], re.IGNORECASE).group(1)
            return f"{float(value)} {unit.lower()}"

    # Special case for voltage
    if entity_type == "VOLTAGE":
        voltage_pattern = r'(\d+(?:\.\d+)?)\s*[Vv](?!\w)'
        voltage_match = re.search(voltage_pattern, text)
        if voltage_match:
            return f"{float(voltage_match.group(1))} V"

    # First, try to find a value in parentheses
    parentheses_pattern = r'\(([\d.,]+)\s*([a-zA-Z]+)\)'
    parentheses_match = re.search(parentheses_pattern, text)
    if parentheses_match:
        value, unit = parentheses_match.groups()
        if (entity_type == "VOLTAGE" and unit.lower() == 'v') or \
           (entity_type == "WATTAGE" and unit.lower() == 'w') or \
           (entity_type in ["WEIGHT", "VOLUME"]):
            return f"{float(value.replace(',', ''))} {unit.lower()}"

    doc = nlp(text)

    # Try spaCy entity extraction
    for ent in doc.ents:
        if ent.label_ == entity_type:
            value = re.findall(r'[\d.,]+', ent.text)[0]
            unit = re.findall(r'[a-zA-Z]+', ent.text)[0]
            return f"{float(value.replace(',', ''))} {unit.lower()}"

    # If spaCy fails, try regex-based extraction
    value_pattern = r'(\d+(?:[.,]\d+)?)'
    unit = fuzzy_unit_match(text, entity_type)

    if unit:
        matches = re.findall(f"{value_pattern}\s*{re.escape(unit)}", text, re.IGNORECASE)
        if matches:
            return f"{float(matches[0].replace(',', ''))} {unit.lower()}"

    # If all else fails, look for any number followed by a known unit
    units = {
        "WEIGHT": ["kg", "g", "mg", "oz", "lbs"],
        "VOLUME": ["l", "ml", "fl oz"],
        "WATTAGE": ["w"],
        "VOLTAGE": ["v"],
        "MAXIMUM_WEIGHT_RECOMMENDATION": [
        "mg", "g", "kg", "kgs", "oz", "lbs", "milligram", "milligrams",
        "gram", "grams", "kilogram", "kilograms", "ounce", "ounces",
        "pound", "pounds", "kg"
    ],
    "HEIGHT": [
        "cm", "ft", "in", "m", "mm", "yard", "yd", "centimetre", "foot",
        "inch", "metre", "millimetre"
    ],
    "WIDTH": [
        "cm", "ft", "in", "m", "mm", "yard", "yd", "centimetre", "foot",
        "inch", "metre", "millimetre"
    ],
    "DEPTH": [
        "cm", "ft", "in", "m", "mm", "yard", "yd", "centimetre", "foot",
        "inch", "metre", "millimetre"
    ],
    "item_volume": [
        "centilitre", "cl", "cubic foot", "ft³", "cubic inch", "in³",
        "cup", "decilitre", "dl", "fluid ounce", "fl oz", "gallon", "gal",
        "imperial gallon", "imp gal", "litre", "l", "microlitre", "µl",
        "millilitre", "ml", "pint", "pt", "quart", "qt"
    ]
    }
    for unit in units[entity_type]:
        matches = re.findall(f"{value_pattern}\s*{unit}", text, re.IGNORECASE)
        if matches:
            return f"{float(matches[0].replace(',', ''))} {unit.lower()}"

    # If still no match, look for any number in the text
    numbers = re.findall(value_pattern, text)
    if numbers:
        #return f"{float(numbers[0].replace(',', ''))} (unit not found)"
        return None

    return None

def get_file_path(file_name):
    if os.path.exists(file_name):
        return file_name
    else:
        user_path = input(f"'{file_name}' not found. Please enter the full path to the file: ")
        if os.path.exists(user_path):
            return user_path
        else:
            raise FileNotFoundError(f"File '{user_path}' not found.")

def get_input_data():
    try:
        text_file = get_file_path('extracted_text.txt')
        entity_file = get_file_path('entity_name.txt')

        with open(text_file, 'r') as f:
            text_snippets = [line.strip() for line in f.readlines() if line.strip()]
        with open(entity_file, 'r') as f:
            entity_types = [line.strip() for line in f.readlines() if line.strip()]

        return text_snippets, entity_types
    except FileNotFoundError as e:
        print(f"Error: {e}")
        return None, None

def write_to_csv(data, filename='extracted_values.csv'):
    # Write data to a CSV file with an Index column
    with open(filename, 'w', newline='') as csvfile:
        fieldnames = ['Index', 'Extracted Value']
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)

        writer.writeheader()
        for index, row in enumerate(data):
            writer.writerow({
                'Index': index,
                'Extracted Value': row['Extracted Value']
            })

# Get input data
text_snippets, entity_types = get_input_data()

if text_snippets and entity_types:
    # Prepare data for CSV
    extracted_data = []

    for text, entity_type in zip(text_snippets, entity_types):
        if entity_type == "item_weight":
            result = extract_entity(text, "WEIGHT")
        elif entity_type == "maximum_weight_recommendation":
            result = extract_entity(text, "MAXIMUM_WEIGHT_RECOMMENDATION")
        elif entity_type == "item_volume":
            result = extract_entity(text, "VOLUME")
        elif entity_type == "wattage":
            result = extract_entity(text, "WATTAGE")
        elif entity_type == "voltage":
            result = extract_entity(text, "VOLTAGE")
        elif entity_type == "height":
            result = extract_entity(text, "HEIGHT")
        elif entity_type == "width":
            result = extract_entity(text, "WIDTH")
        elif entity_type == "depth":
            try:
              result = extract_entity(text, "DEPTH")
            except:
              result = None
        else:
            result = None


        extracted_data.append({
            'Extracted Value': result
        })

        print(f"Text: {text}")
        print(f"Entity Type: {entity_type}")
        print(f"Extracted Value: {result}")
        print()

    # Write the extracted data to CSV
    write_to_csv(extracted_data)

else:
    print("Unable to process data due to missing input files.")

